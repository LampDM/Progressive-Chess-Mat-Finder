
\documentclass[runningheads]{llncs}
\usepackage{graphicx}
\usepackage{apacite}
\usepackage{float}
\usepackage{listings}
\begin{document}

\title{Seminarska naloga 1}
\subtitle{Iskanje šah matov pri 1-2-3 šahu}

\author{Danijel Maraž}


\institute{Fakulteta za Računalništvo in Informatiko UL
\email{dm9929@student.uni-lj.si}\\
}

\maketitle             

\begin{abstract}
The article covers the work done in the scope of the first seminar assignment as part of the subject Algorithms. 

\keywords{A* BFS Progressive Chess Heuristics Pathfinding}
\end{abstract}

\section{Uvod}
Pri seminarski nalogi nam je bil dan cilj implementiranja algoritma A* (A zvezda) v namen iskanja
potez, ki vodijo do šah mata pri dani postavitvi šahovskih figur. Kot jezik implementacije sem si izbral Python, ker menim, da se z njim da pisati lepšo in bolj berljivo kodo. Iz drugega vidika pa je tudi bistveno počasnejši od Jave. Če bi torej program pisal za trg bi ga zagotovo s pomočjo jezika, ki se hitreje izvaja. 

\section{Struktura programa}



\begin{lstlisting}
def BFS_move(brd, c):
    visited = set()
    nextq = [(0, c, id(brd), brd)]
    heapq.heapify(nextq)
    while nextq:
		
		#Pop best rated board
        current = heapq.heappop(nextq)
        current[3].turn = moveside
		
		#Add board to visited
        zh = zobrist_hash(current[3])
        visited.add(zh - current[1])
        
        # Check if the given position is a checkmate
        if current[1] == 0:
            current[3].turn = enemyside
            if current[3].is_checkmate():
                sstr = ""
                moveslist = [str(m) for m in current[3].move_stack]
                for move in moveslist:
                    sstr += move[:2] + "-" + move[2:] + ";"
                print(sstr[:-1])
                break
            current[3].turn = moveside
            continue
\end{lstlisting}
Funkcija \textit{BFS\_move} prejme kot argumenta \textit{brd} (board razred Python šahovkse knjižnice inicializiran iz fen notacije posamezne testne datoteke) in \textit{c} (koliko potez ima program na voljo). Takoj za tem ustvarimo množico \textit{visited}, ki hrani zgoščene slike že videnih šahovnic ter min kopico \textit{nextq}. Ta hrani terke oblike \textit{(ocena, št. potez, identifikator, šahovnica)} in jih med seboj razporeja glede na prvi element. Nato se začne prva while zanka, ki se izvaja vse dokler ne najdemo šah mata ali dokler ni kopica \textit{nextq} prazna. Nadalje iz kopice pridobimo najnižje ocenjeno terko, zgoščeno sliko njene šahovnice dodamo k množici \textit{visited} in ob pogoju, da ta nima več na voljo potez preverimo ali smo prišli do šah mata.
\begin{lstlisting}
        # The main loop
        for move in current[3].legal_moves:

            sc = current[1]

            current[3].push(move)
            current[3].turn = moveside

            # Eliminate premature attacks on the king
            # Eliminate last moves that don't attack the king
            wic = current[3].was_into_check()
            if (sc > 1 and wic) or (sc == 1 and not wic):
                current[3].pop()
                continue

            # Check if we already saw this board before
            zh = zobrist_hash(current[3])
            if zh - (sc - 1) in visited:
                current[3].pop()
                continue
\end{lstlisting}
Z zgornjo zanko nato pregledamo zalogo vseh dovoljenih potez in marsikatero že na osnovi osnovnih pravil 1-2-3 šaha izločimo. Potezo porinemo na sklad potez izbrane šahovnice in s pomočjo funkcije \textit{was\_into\_check()} preverimo ali je bil kralj napaden pred zadnjo potezo in ali smo prišli do zadnje poteze brez, da bi napadli kralja. V obeh primerih se poteza odstrani iz sklada ter zanka vrne na začetek. Potezo prav tako preskočimo, če s pomočjo množice \textit{visited} ugotovimo, da smo šahovnico že obiskali pri danem številu potez. \\
 Bistvene izboljšave na tem področju:
\begin{itemize}
  \item Najprej smo za vsako novo potezo naredili kopijo šahovnice in na njej izvajali preverjanja kar se je izkazalo kot zelo potratno, saj je kopiranje celotne instance razreda počasna operacija. Boljša alternativa je bila posamezne poteze preprosto poriniti na sklad že obstoječe instance.
  \item Smiselno bi bilo, da bi takoj preverili ali smo šahovnico že videli, ampak je v praksi operacija zgoščevanja izjemno počasna. Izkazalo se je da je veliko hitrejše poteze najprej izločiti glede na pravila igre kot pa za vsako potezo računati zgoščevalno funkcijo.
\end{itemize}
\begin{lstlisting}
            r = 0
            # Reward promotions
            prom = move.promotion
            if prom is not None:
                r -= -200
                if prom == chess.Piece(5, moveside):
                    r -= 300
                if prom == chess.Piece(4, moveside):
                    r -= 200

            # Desperate measures
            if (time.time() - start) > 17:
                rand = random.randint(1, 20)
                r += rand

            # Reward last turn
            if sc == 1:
                r -= 1000

            # Apply various heuristics

            # Coverage of squares around the King
            r -= KSCoverage(current[3], board.king(enemyside))
            # Manhattan distance from the new position of the piece that moved
            r += ManhattanLight(move, board.king(enemyside))

            # Reward depth
            r -= (sc - 1) * 100

            ccopy = current[3].copy()
            current[3].pop()

            heapq.heappush(nextq, (r, sc - 1, id(ccopy), ccopy))
\end{lstlisting}
Spremenljivka \textit{r} hrani točke pri ocenjevanju nove šahovnice. Nad njo se izvede vrsta preverjanj, ki tej spremenijo vrednost in na koncu se v min kopico pošlje terka z vsoto vseh ocen.

\section{Hevristike}

\subsection{Promocije}
Promocije figur, ki so bistven del igre 1-2-3 šaha se nagrajuje z -200 točkami. Iz izkušenj igranja 1-2-3 šaha vem, da sta najpogostejši figuri pri promocijah kraljica in trdnjava. Zato zanju program prejme dodatnih -300 in -200 točk.
\subsection{Naključnost}
Če čas izvajanja programa preseže 17 sekund se vsaki novi šahovnici doda naključno število točk med 0 in 20. S tem programu omogočimo večjo dinamičnost pri izbiri naslednje šahovnice in nam naključna srečna izbira lahko drastično izboljša rezultate.
\subsection{Nagrajevanje dosega končne poteze}
Izkazalo se je, da je najboljše program prisiliti k takojšnjemu pregledu šahovnic, ki nimajo 
\subsection{Pokritost polj kralja}
\subsection{Manhattan razdalja}
\subsection{Nagrajevanje globine}

\section{Ovrednotev}

\section{Programska koda}

 \bibliographystyle{apacite}
 
 \bibliography{references}


\end{document}
